import faiss
import json
import numpy as np
from typing import List, Dict, Any

class FAISSVectorStore:
    """
    A wrapper class for a simple FAISS (CPU) vector store.
    It loads a pre-built index and a JSON mapping file.
    """
    
    def __init__(self, index_path: str, mapping_path: str):
        """
        Initializes the vector store.

        Args:
            index_path: Path to the .index file generated by FAISS.
            mapping_path: Path to the .json file mapping index IDs to data.
        """
        print(f"Loading FAISS index from {index_path}")
        self.index = faiss.read_index(index_path)
        
        print(f"Loading JSON mapping from {mapping_path}")
        with open(mapping_path, 'r', encoding='utf-8') as f:
            self.mapping = json.load(f)
            
        # JSON keys are strings, but FAISS indices are integers.
        # We convert keys to integers for easy lookup.
        try:
            self.mapping = {int(k): v for k, v in self.mapping.items()}
        except Exception as e:
            print(f"Error converting mapping keys to int: {e}")
            print("Warning: Mapping may not function correctly.")

    def search(self, query_vector: List[float], k: int = 5) -> List[Dict[str, Any]]:
        """
        Searches the FAISS index for the top-k most similar vectors.

        Args:
            query_vector: The embedding of the user's query.
            k: The number of results to return.

        Returns:
            A list of "chunk" dictionaries, each corresponding to a retrieved page.
        """
        #if not query_vector:
        #    print("Error: Empty query vector.")
        #    return []
            
        # FAISS requires a 2D numpy array of type float32
        query_np = np.array([query_vector]).astype('float32')
        
        # Perform the search
        distances, indices = self.index.search(query_np, k)
        
        results = []
        if not indices.size > 0:
            return []
            
        # Retrieve the metadata for each result
        for idx in indices[0]:
            if idx == -1:
                # -1 means no result (if k > number of items)
                continue
                
            # Map the FAISS index (0-based) to our stored metadata
            chunk_data = self.mapping.get(idx)
            
            if chunk_data:
                results.append(chunk_data)
            else:
                print(f"Warning: No mapping found for index {idx}")
                
        return results